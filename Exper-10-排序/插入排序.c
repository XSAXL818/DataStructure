#include <stdio.h>


// 基本思路 (增序)
// 数组分为 已排好序的数组A和待排序的数组B, 已排好序的数组A置于整体数组的前面，
// 每次循坏，提取待排序数组B中的一个元素，(默认为已排好序A的后一位)然后将该元素与A的尾巴依次对比，
// 如果小于A中元素，则将A中该元素后移一位，如果大于则插入到该元素的后面一位
// 外层循环 len-1 ： 即默认数组第一个元素是已排序的序列，然后依次从剩下的len-1个元素插入到已排好的序列
// 内层循环最大为 已排好数组的长度。
// 本方法事时间复杂度  最好O(N^2) 最坏O(N)  稳定
// 算法自身缺陷，需要不断的交换元素，

// 排列为增序, len是数组的总长度，包括哨兵
void insertSort( int arr[], int len ){// 利用带哨兵的数组
	
	int i,j,t;
	for( i = 2; i < len ; i++ ){// 最外层 对len-1个元素进行插入
		arr[0] = arr[i];// 哨兵保存要插入的元素的
		for( j = i - 1; arr[j] > arr[0]; j--  ){// 此层循环：从已排好序的末尾开始依次找寻好插入的位置
			arr[j+1] = arr[j];// 将该元素后移一位
		}
		// 循环结束，要插入的位置为j+1,即找到了已排好序中第一个小于等于要插入的元素
		arr[j+1] = arr[0];
	}
}


int main(){
	
	int arr[10] = { 1, 5, 2, 10, 87, 22, 32, 12, 77, 54 };
	insertSort( arr, 10 );
	int i;
	for( i = 1; i < 10; i++ ){
		printf("%d ",arr[i]);
	}
	
	
	
	
	
	
	return 0;
}